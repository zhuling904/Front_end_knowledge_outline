# web

# 1.如何进行网站性能优化

- content方面
  - 减少`HTTP`请求：合并文件、`CSS`精灵、`inline Image`
  - 减少`DNS`查询：`DNS`缓存、将资源分布到恰当数量的主机名
  - 减少`DOM`元素数量

- Server方面
  - 使用`CDN`
  - 配置`ETag`
  - 对组件使用`Gzip`压缩

- Cookie方面
  - 减小`cookie`大小
- css方面
  - 将样式表放到页面顶部
  - 不使用`CSS`表达式
  - 使用`<link>`不使用`@import`

- Javascript方面
  - 将脚本放到页面底部
  - 将`javascript`和`css`从外部引入
  - 压缩`javascript`和`css`
  - 删除不需要的脚本
  - 减少`DOM`访问

- 图片方面
  - 优化图片：根据实际颜色需要选择色深、压缩
  - 优化`css`精灵
  - 不要在`HTML`中拉伸图片

# 2.你有用过哪些前端性能优化的方法？

- 减少`http`请求次数：`CSS Sprites`, `JS`、`CSS`源码压缩、图片大小控制合适；网页`Gzip`，`CDN`托管，`data`缓存 ，图片服务器。
- 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存`AJAX`请求结果，每次操作本地变量，不用请求，减少请求次数
- 用`innerHTML`代替DOM操作，减少DOM操作次数，优化javascript性能。
- 当需要设置的样式很多时设置`className`而不是直接操作`style`
- 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作
- 避免使用`CSS Expression`（css表达式)又称`Dynamic properties`(动态属性)
- 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳
- 避免在页面的主体布局中使用`table`，`table`要等其中的内容完全下载之后才会显示出来，显示比`div+css`布局慢

# 3.谈谈性能优化问题

- 代码层面：避免使用`css`表达式，避免使用高级选择器，通配选择器
- 缓存利用：缓存`Ajax`，使用`CDN`，使用外部`js`和`css`文件以便缓存，添加`Expires`头，服务端配置`Etag`，减少`DNS`查找等
- 请求数量：合并样式和脚本，使用`css`图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载
- 请求带宽：压缩文件，开启`GZIP`

# 4.前端性能优化最佳实践？

- 性能评级工具（`PageSpeed` 或 `YSlow`）
- 合理设置 `HTTP` 缓存：`Expires` 与 `Cache-control`
- 静态资源打包，开启 Gzip 压缩（节省响应流量）
- `CSS3` 模拟图像，图标`base64`（降低请求数）
- 模块延迟(defer)加载/异步(`async`)加载
- `Cookie` 隔离（节省请求流量）
- `localStorage`（本地存储）
- 使用 `CDN` 加速（访问最近服务器）
- 启用 `HTTP/2`（多路复用，并行加载）
- 前端自动化（`gulp/webpack`）



# 5.WEB标准以及W3C标准是什么?

WEB标准是指由万维网联盟（World Wide Web Consortium，简称W3C）制定的一系列技术规范和指南，旨在确保网页在不同的浏览器和设备上具有一致的表现和行为。这些标准涵盖了HTML、CSS、JavaScript等前端技术，并规定了它们的语法、结构、样式以及交互行为等方面的规范。

W3C标准是由W3C组织制定和推广的一系列技术标准，旨在推动网络技术的发展和互操作性。W3C是一个国际性的标准化组织，由互联网行业的各大公司、研究机构和个人组成，致力于制定并推广互联网的开放标准。W3C标准包括HTML、CSS、XML、DOM、SVG等多个技术领域，并且不断更新和演进，以适应新的需求和技术发展。

**具体来说，WEB标准和W3C标准强调以下几个方面：**

- **标签闭合**：HTML标签必须按照规定的格式正确闭合，以确保页面结构的准确性和一致性。
- **标签小写**：HTML标签和属性应该使用小写字母，以避免浏览器解析错误。
- **不乱嵌套**：HTML标签应该按照正确的嵌套规则进行使用，不应该出现乱七八糟的嵌套结构，以确保页面结构的清晰和可维护性。
- **使用外链CSS和JS**：将CSS样式和JavaScript代码尽可能地放在外部文件中，并通过链接的方式引入，以实现结构、行为和表现的分离，提高代码的可重用性和可维护性。

通过遵循这些标准和规范，开发人员可以编写出更加规范、可靠和跨平台的网页，确保网页在不同的浏览器和设备上得到一致的显示和行为，提供更好的用户体验。此外，遵循WEB标准和W3C标准还有助于网页的可访问性、可维护性和可扩展性，同时推动互联网技术的进步和发展。

# 6.xhtml和html有什么区别?

- 一个是功能上的差别
  - 主要是`XHTML`可兼容各大浏览器、手机以及`PDA`，并且浏览器也能快速正确地编译网页
- 另外是书写习惯的差别
  - `XHTML` 元素必须被正确地嵌套，闭合，区分大小写，文档必须拥有根元素

# 7.Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?

- `DOCTYPE`（文档类型声明）的作用是告知浏览器的解析器使用哪种`HTML`或`XHTML`规范来解析文档。
- 严格模式（标准模式）是指浏览器按照`HTML`或`XHTML`的规范严格解析和渲染页面，以确保页面在不同浏览器中具有一致的展示效果和行为。在严格模式下，浏览器会按照规范要求的方式处理`HTML`和`CSS`代码。
- 混杂模式（怪异模式或兼容模式）是指浏览器使用较宽松的解析方式来渲染页面，以模拟旧式浏览器的行为，以保证旧版网站的兼容性。在混杂模式下，浏览器可能会容忍一些不符合规范的`HTML`和CSS`代码，导致页面展示和行为在不同浏览器中有差异。
- 通过`DOCTYPE`声明的类型来区分严格模式和混杂模式。当`DOCTYPE`声明为严格的`HTML`或`XHTML`规范时，浏览器会进入严格模式；当`DOCTYPE`声明缺失或格式不正确时，浏览器会进入混杂模式。
- 严格模式和混杂模式的意义在于确保页面在不同浏览器中的一致性和兼容性。严格模式使开发者能够使用更规范的`HTML`和`CSS`代码，减少兼容性问题，提高网页的可靠性和可维护性。混杂模式则用于支持旧版网站，以确保这些网站在新版浏览器中能够正确显示和运行。

# 8.行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？行内元素和块级元素有什么区别？

- 行内元素有：`a` `b` `span` `img` `input` `select` `strong`等。
- 块级元素有：`div` `ul` `ol` `li` `dl` `dt` `dd` `h1` `h2` `h3` `h4`等标题标签、`p` 段落标签等。
- 空元素（void元素）是指没有内容的HTML元素。常见的空元素包括：`<br>` 换行元素、`<hr>` 水平线元素、`<img>` 图片元素、`<input>` 输入框元素、`<link>` 样式表引用元素、`<meta>` 元数据元素等。
- 行内元素不可以设置宽高，不独占一行，它们会按照从左到右的顺序排列，并尽可能占据内容所需的空间。
- 块级元素可以设置宽高，独占一行，会自动换行。块级元素会在页面上以独立的块形式展现，并占据其父元素的整个宽度。

请注意，这是以Markdown源文件格式输出的回答，不会解析Markdown内容。

# 9.HTML全局属性(global attribute)有哪些

- `class`:为元素设置类标识
- `data-*`: 为元素增加自定义属性
- `draggable`: 设置元素是否可拖拽
- `id`: 元素`id`，文档内唯一
- `lang`: 元素内容的的语言
- `style`: 行内`css`样式
- `title`: 元素相关的建议信息

# 10.Canvas和SVG有什么区别？

> - `svg`绘制出来的每一个图形的元素都是独立的`DOM`节点，能够方便的绑定事件或用来修改。`canvas`输出的是一整幅画布
> - `svg`输出的图形是矢量图形，后期可以修改参数来自由放大缩小，不会失真和锯齿。而`canvas`输出标量画布，就像一张图片一样，放大会失真或者锯齿

你对Canvas和SVG的区别的描述是正确的。以下是对Canvas和SVG的更详细解释：

**Canvas：**

- Canvas 是一个HTML5元素，用于在网页上绘制图形、动画和图像。
- 通过使用JavaScript绘制图形，Canvas提供了一个像素级的绘图环境。
- Canvas 绘制的是位图，它是由一系列的像素组成的，所以在放大时会出现像素失真或锯齿效应。
- Canvas 不会保留绘图的对象，绘制完成后，图形将被保存为一张图片。
- 由于绘制是基于像素的，Canvas 更适合处理像素级的图像处理、游戏开发等场景。
- Canvas 不支持事件绑定，需要通过监听鼠标、键盘等事件来实现交互。

**SVG：**

- SVG 是一种基于XML的矢量图形格式，用于在网页上绘制图形和图像。
- SVG 使用XML描述图形，它由一系列的矢量对象组成，可以方便地修改和操作。
- SVG 绘制的是矢量图形，它基于数学描述，可以自由缩放和变换而不会失真或产生锯齿效应。
- SVG 保留了绘图的对象，可以对其进行修改、删除和动态操作。
- 由于是矢量图形，SVG 更适合处理图表、数据可视化和可缩放的图形场景。
- SVG 支持事件绑定，可以方便地为图形元素添加交互行为。

> 综上所述，Canvas适用于像素级绘图和动画，而SVG适用于矢量图形和可缩放的图像。选择使用Canvas还是SVG取决于具体的需求和场景。

# 11. HTML5 为什么只需要写 `<!DOCTYPE HTML>`

- `HTML5` 不基于 `SGML`，因此不需要对`DTD`进行引用，但是需要`doctype`来规范浏览器的行为
- 而`HTML4.01`基于`SGML`,所以需要对`DTD`进行引用，才能告知浏览器文档所使用的文档类型

下面是对此进行更详细的解释：

- 在 HTML5 中，不再基于 SGML（Standard Generalized Markup Language）标准，而是定义了自己的独立规范。由于不再使用 SGML，因此不需要引用外部的 DTD（文档类型定义）来验证文档的结构和规则。
- 因此，HTML5 只需要简单地使用 `<!DOCTYPE HTML>` 声明，它是一个标准模式的声明，告诉浏览器当前文档遵循的是 HTML5 规范。这样，浏览器就可以根据 HTML5 规范来解析和渲染文档，而无需引用外部的 DTD。
- 相比之下，HTML4.01 基于 SGML 标准，需要通过 `<!DOCTYPE>` 声明来指定所使用的 DTD，例如 `<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">`。这个 DTD 提供了规范的文档结构和规则，以确保浏览器正确解析和显示文档。
- HTML5 的简化 `<!DOCTYPE HTML>` 声明的设计，使得创建和编写 HTML 文档更加简单和直观。此外，这也有助于提高浏览器的兼容性，因为所有的浏览器都会将文档解析为 HTML5，无需根据 DTD 进行选择和适配。
- 总结起来，HTML5 不再依赖 SGML，因此不需要引用外部 DTD，只需使用简单的 `<!DOCTYPE HTML>` 声明来指定文档类型，规范浏览器的行为。

# 12.网页验证码是干嘛的，是为了解决什么安全问题

网页验证码（CAPTCHA）的作用是用于区分用户是计算机还是人的公共全自动程序。它主要解决以下安全问题：

1. **防止恶意破解**：通过要求用户输入验证码，可以防止恶意用户使用自动化程序（如暴力破解工具）对密码、账号进行不断的尝试，提高系统的安全性。
2. **防止刷票和论坛灌水**：验证码可以阻止自动化程序大规模注册账号、刷票或在论坛上进行大量无意义的发帖，保护网站资源免受滥用。

通过要求用户正确地输入验证码，可以验证用户的身份，确保其为真实的人类用户，而不是自动化程序或恶意攻击者。验证码通常会显示一张包含随机字符、数字或图形的图片，用户需要根据图片中的内容进行识别并输入正确的答案。

这样，网页验证码有效地提高了网站和应用程序的安全性，防止了各种恶意行为的发生。

# 13.web开发中会话跟踪的方法有哪些

- **Cookie**: 使用Cookie是最常见的会话跟踪方法之一。服务器在响应中设置一个包含会话ID的Cookie，然后在后续的请求中，浏览器会自动将该Cookie发送回服务器，以标识用户的会话。
- **Session**: 服务器使用会话来跟踪用户的状态。每个会话都会分配一个唯一的会话ID，该ID通常存储在Cookie中或通过URL重写传递给服务器。服务器使用会话ID来关联用户的请求，并在服务器端存储会话数据。
- **URL重写**: 将会话ID作为查询参数添加到URL中，以便在每个请求中传递会话信息。这种方法不需要依赖Cookie，适用于禁用Cookie的情况，但会增加URL的长度并暴露会话信息。
- **隐藏input**: 在表单中添加一个隐藏的input字段，将会话ID作为其值传递给服务器。服务器接收到请求时可以通过解析请求参数获取会话ID，以进行会话跟踪。
- **IP地址**: 使用客户端的IP地址作为会话跟踪的依据。服务器根据不同的IP地址来区分不同的用户，并跟踪他们的会话状态。然而，由于多个用户可能共享相同的IP地址（如在同一局域网内），这种方法可能不准确。

这些方法可以单独或结合使用，根据实际需求和安全考虑选择适当的会话跟踪方法。

# 14.请你谈谈Cookie的弊端

`cookie`虽然在存储客户端数据方面提供了方便，并减轻了服务器的负担，但它也存在一些弊端和限制，包括：

- **数量限制**：每个特定域名下的`cookie`数量有限。例如，旧版的`IE6`最多允许20个`cookie`，而`IE7`及更高版本允许50个`cookie`，其他浏览器也有类似的限制。
- **大小限制**：每个`cookie`的大小也有限制，通常为约`4096`字节（不同浏览器可能有差异），为了兼容性，一般建议将`cookie`大小控制在`4095`字节以内。
- **清理策略**：一些浏览器会根据策略清理过期或不常使用的`cookie`，这可能会导致某些数据丢失或需要重新设置。
- **安全性问题**：`cookie`存储在客户端，如果被恶意拦截，攻击者可以获取其中的数据，包括`session`信息，可能导致安全隐患。
- **跨域限制**：`cookie`在同源策略下工作，无法跨域访问。每个域名下的`cookie`只能被同域名的页面访问和修改。
- **对网络性能的影响**：`cookie`会增加每个请求的数据量，从而增加了网络传输的开销，尤其在请求大量静态资源的网页时，会对加载速度产生一定的影响。

要解决这些问题，可以使用其他存储方式，如`localStorage`或`sessionStorage`，使用服务器端存储来替代部分或全部`cookie`，或者通过其他技术手段来优化和管理`cookie`的使用。



