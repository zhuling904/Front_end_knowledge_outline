# 闭包

# 一、闭包是什么？

记住闭包就是**一种现象**，具体来说，当一个函数可以访问并操作其定义时所处的作用域中的变量时，就称之为闭包。这种现象是由编程语言的设计和实现所决定的。对于Js来说，由于Js的作用域机制使内部函数可以访问外部函数的作用域，也就是可以访问外部函数的变量，反过来却不行（下面会解释这些原因），但是闭包打破了这种规则，可以使外部函数访问内部函数的变量。

那么这里就有几个问题：

+ 为什么Js的作用域机制使内部函数可以访问外部函数的作用域，但是反过来却不行？
+ 闭包是怎样打破这种规则的？
+ 为什么内部函数引用了外部函数的变量，这个变量就不会被清除？



# 二、作用域和执行上下文

## 1.作用域

要理解闭包首先要理解Js的作用域是什么？是怎么做的？

### （1）什么是作用域？

作用域就是变量的生命周期，变量什么时候被创建，什么时候被清除，在什么范围内有效？作用是什么？

作用域是一套规则，用于确定在代码中哪些变量可以被访问，以及它们的可见性范围。在 JavaScript 中，作用域是基于函数的，也就是说每个函数都有自己的作用域。变量的作用域通常被定义在函数体内，在函数外部无法访问。在 ES6 中，let 和 const 关键字引入了块级作用域，即花括号 {} 内部定义的变量仅在该块内部可见。作用域最大的作用就是隔离变量，不同作用域下的变量不会有冲突。

```js
function foo() {
  var x = 1;
  let y = 2;
  
  console.log(x, y);
}

foo(); // 输出 1 2

console.log(x, y); // 抛出 ReferenceError，因为 x 和 y 在全局作用域中不可见

```

### （2）作用域分类、全局、函数、块级

+ **全局作用域**

在 JavaScript 中，全局作用域是指在整个代码中都可以访问的变量和函数的作用域。在浏览器中，全局作用域是 window 对象，在全局作用域中声明的变量和函数可以被所有函数访问，而不管它们是在哪个函数内声明的。这也意味着在全局作用域中声明的变量和函数都是全局变量和全局函数，它们可能会被其他代码修改或覆盖，因此需要谨慎使用。

```js
var x = 1;

function foo() {
  console.log('Hello, world!');
}

console.log(x); // 输出 1

foo(); // 输出 'Hello, world!'

```



+ **函数作用域**

在 JavaScript 中，函数作用域是指在函数内部声明的变量和函数只能在该函数内部访问和修改。这种作用域称为局部作用域或函数作用域。函数作用域是一种非常重要的概念，它允许我们在函数内部创建变量和函数，而不必担心与其他函数或全局作用域中的变量和函数冲突。

例如，以下代码中的变量 `x` 和函数 `foo` 都是在函数 `bar` 内部声明的：

```js
function bar() {
  var x = 1;

  function foo() {
    console.log('Hello, world!');
  }

  console.log(x); // 输出 1

  foo(); // 输出 'Hello, world!'
}

bar();
```



+ **块级作用域（`let、const`)** 

在 JavaScript ES6 中引入了块级作用域，块级作用域是指在花括号 `{}` 内声明的变量或函数只能在该块级作用域内访问和修改，超出该块级作用域范围后就会被销毁。这种作用域称为块级作用域或局部作用域。

在 ES6 之前，JavaScript 中只有全局作用域和函数作用域，因此在使用 `for` 循环、`if` 语句等结构时，通常需要使用闭包或立即执行函数表达式来创建块级作用域。而 ES6 引入的块级作用域，则可以更加方便地创建临时变量和临时函数，从而避免了一些常见的问题和陷阱。

例如，以下代码中的变量 `x` 只能在 `if` 语句块级作用域内访问和修改：

```js
if (true) {
  let x = 1;
  console.log(x); // 输出 1
}

console.log(x); // 抛出 ReferenceError，因为 x 在全局作用域中不可见
```

在这个例子中，变量 `x` 只能在 `if` 语句块级作用域内访问和修改，超出该块级作用域范围后就会被销毁。这种作用域的好处是它可以避免变量污染和命名冲突，使代码更加模块化和可维护。

### （3）作用域链

作用域链是指在 JavaScript 中，每个执行环境（也就是函数）都有一个关联的作用域链，用于解析变量和函数的引用。作用域链是由多个变量对象组成的链表，它保存了当前执行环境（也就是当前函数）以及所有外层函数的变量对象。通过作用域链，JavaScript 引擎可以在嵌套的函数中找到变量和函数，从而实现作用域的概念。

当在一个函数中访问变量或函数时，JavaScript 引擎会首先在当前函数的变量对象中查找该变量或函数，如果找不到，则会向上遍历作用域链，直到找到该变量或函数为止。如果最终都没有找到，则会抛出 ReferenceError 异常。

例如，以下代码中的变量 `x` 和函数 `foo` 的作用域就是在 `bar` 函数的作用域内，它们都可以通过作用域链访问到：

```js
function bar() {
  var x = 1;

  function foo() {
    console.log(x);
  }

  foo();
}

bar();

```

在这个例子中，函数 `foo` 可以访问变量 `x`，因为它们在同一个作用域链中，也就是 `bar` 函数的作用域链中。当调用 `foo()` 函数时，JavaScript 引擎会在当前执行环境（也就是 `foo` 函数的作用域）的变量对象中查找变量 `x`，由于找不到，因此会向上遍历作用域链，最终找到变量 `x`，并将其值输出。



下面这篇文章绘图解释了作用域链的查找机制，**由内而外**

[图解作用域链](https://juejin.cn/post/7027820322820735006)



## 2.执行上下文

### （1）作用域和执行上下文的区别

区别一下作用域和执行上下文

​		作用域是指变量和函数的可访问范围，它是在代码编写时静态决定的，即在代码执行之前就已经确定了。JavaScript 中有全局作用域、函数作用域和块级作用域三种作用域。作用域的主要作用是保护变量和函数不受外部影响，避免命名冲突。

​		执行上下文是指在执行 JavaScript 代码前，JavaScript 引擎创建的一个内部数据结构，用于跟踪代码的执行情况，它包含了变量、函数、this 指针等信息。执行上下文在代码执行时动态创建，并随着代码的执行不断变化。JavaScript 中有全局执行上下文和函数执行上下文两种执行上下文。执行上下文的主要作用是管理变量和函数的生命周期，以及处理函数的调用栈、变量声明、this 指针等问题。



JavaScript属于解释型语言，JavaScript的执行分为：解释和执行两个阶段,这两个阶段所做的事并不一样：

- 在解释阶段，JavaScript 引擎会对代码进行词法分析和语法分析，生成抽象语法树（AST）和执行上下文（Execution Context）。这个过程会对代码中的语法错误进行检测，并对变量和函数进行声明和初始化。在这个阶段，JavaScript 引擎并不会执行代码，只是对代码进行了一些预处理，为后续的执行阶段做好准备。
- 在执行阶段，JavaScript 引擎会按照代码的顺序执行每一条语句，并根据执行上下文中的变量和函数定义，对变量进行赋值和函数进行调用。在执行阶段，JavaScript 引擎会执行代码中的各种操作，包括算术运算、比较运算、逻辑运算等，还会涉及到各种对象的创建和操作，如数组、对象、函数等。

### （2）执行上下文的分类

JavaScript 中有三种执行上下文类型。

- **全局执行上下文**是在页面加载时创建的，它是整个程序的根执行上下文。在全局执行上下文中定义的变量和函数都是全局可见的，可以在程序中的任何地方被访问。全局执行上下文只有一个，它在整个程序运行期间都存在。



- **函数执行上下文**是在调用函数时创建的，每次调用函数都会创建一个新的函数执行上下文。在函数执行上下文中，会有一些特定的操作，如创建参数对象、变量声明、建立作用域链等。函数执行上下文与函数一一对应，每次调用函数都会创建一个新的函数执行上下文，函数执行完毕后，它的函数执行上下文会被销毁。这里也是作用域和上下文的区别，作用域只有一个，但是上下文可以有多个或者没有。



- **eval 执行上下文**是在使用 eval() 函数时创建的，它会将传入的字符串作为 JavaScript 代码进行解析和执行。在 eval 执行上下文中，会对传入的字符串进行词法分析和语法分析，并生成对应的抽象语法树和执行上下文。eval 执行上下文通常不推荐使用，因为它会影响代码的可读性和可维护性。

  

### （3）执行栈

执行栈（`Execution Stack`），也称为调用栈（`Call Stack`），是一种数据结构，用于记录程序在执行过程中函数调用的顺序和上下文关系。在 js 中，每当调用一个函数时，就会创建一个新的执行上下文并压入执行栈中，当函数执行完成后，它的执行上下文会从执行栈中弹出，控制权回到上一个执行上下文中。

执行栈采用后进先出（LIFO）的方式管理执行上下文。也就是说，最后压入执行栈的执行上下文会最先被执行，而最先压入执行栈的执行上下文会最后被执行。例如，如果函数 A 调用了函数 B，那么执行顺序为 A -> B，即先执行函数 A，再执行函数 B，当函数 B 执行完成后，将从执行栈中弹出函数 B 的执行上下文，控制权回到函数 A 的执行上下文中。

```js
function funcA() {
  console.log("funcA");
}

function funcB() {
  funcA();
  console.log("funcB");
}

function funcC() {
  funcB();
  console.log("funcC");
}

funcC();

```



在执行过程中，执行栈的变化如下：

1. 当程序开始执行时，会创建全局执行上下文并将其压入执行栈中。
2. 执行到 `funcC()` 函数调用时，会创建 `funcC()` 函数的执行上下文并将其压入执行栈中，此时执行栈的顶部为 `funcC()` 函数的执行上下文。
3. 在 `funcC()` 函数中调用 `funcB()` 函数时，会创建 `funcB()` 函数的执行上下文并将其压入执行栈中，此时执行栈的顶部为 `funcB()` 函数的执行上下文。
4. 在 `funcB()` 函数中调用 `funcA()` 函数时，会创建 `funcA()` 函数的执行上下文并将其压入执行栈中，此时执行栈的顶部为 `funcA()` 函数的执行上下文。
5. 当 `funcA()` 函数执行完毕后，其执行上下文会从执行栈中弹出，控制权回到 `funcB()` 函数的执行上下文中，此时执行栈的顶部为 `funcB()` 函数的执行上下文。
6. 当 `funcB()` 函数执行完毕后，其执行上下文会从执行栈中弹出，控制权回到 `funcC()` 函数的执行上下文中，此时执行栈的顶部为 `funcC()` 函数的执行上下文。
7. 当 `funcC()` 函数执行完毕后，其执行上下文也会从执行栈中弹出，此时执行栈中只剩下全局执行上下文。



### （4）执行栈的创建







# 五、经典问题



# 六、闭包应用

